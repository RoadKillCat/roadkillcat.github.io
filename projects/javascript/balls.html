---
layout: default
---

<h1>Bouncing Balls</h1>

<h2>Run a <a href='https://joeiddon.github.io/balls/?data=%7B%22bollards%22%3A%5B%7B%22type%22%3A%22rect%22%2C%22points%22%3A%5B%7B%22x%22%3A26%2C%22y%22%3A684%7D%2C%7B%22x%22%3A578%2C%22y%22%3A804%7D%2C%7B%22x%22%3A572.1064981949459%2C%22y%22%3A831.1101083032491%7D%2C%7B%22x%22%3A20.106498194945846%2C%22y%22%3A711.1101083032491%7D%5D%7D%5D%2C%22spawn_areas%22%3A%5B%7B%22x%22%3A10%2C%22y%22%3A11%2C%22w%22%3A575%2C%22h%22%3A659%2C%22no_balls%22%3A5%2C%22min_radius%22%3A30%2C%22max_radius%22%3A10%2C%22min_vel%22%3A0%2C%22max_vel%22%3A40%2C%22vel_angle%22%3A-1%7D%5D%2C%22tracing%22%3Afalse%2C%22collisions%22%3Atrue%2C%22gravity%22%3A200%2C%22cor%22%3A1%2C%22size%22%3A856%7D'>basic</a>, <a href='https://joeiddon.github.io/balls/?data=%7B%22bollards%22%3A%5B%5D%2C%22spawn_areas%22%3A%5B%7B%22x%22%3A383%2C%22y%22%3A118%2C%22w%22%3A60%2C%22h%22%3A29%2C%22no_balls%22%3A100%2C%22min_radius%22%3A3%2C%22max_radius%22%3A3%2C%22min_vel%22%3A0%2C%22max_vel%22%3A0%2C%22vel_angle%22%3A-1%7D%2C%7B%22x%22%3A395%2C%22y%22%3A107%2C%22w%22%3A37%2C%22h%22%3A51%2C%22no_balls%22%3A100%2C%22min_radius%22%3A3%2C%22max_radius%22%3A3%2C%22min_vel%22%3A0%2C%22max_vel%22%3A0%2C%22vel_angle%22%3A-1%7D%5D%2C%22tracing%22%3Afalse%2C%22collisions%22%3Atrue%2C%22gravity%22%3A400%2C%22cor%22%3A1%2C%22size%22%3A856%7D'>explosion</a> or <a href='https://joeiddon.github.io/balls/?data=%7B%22bollards%22%3A%5B%5D%2C%22spawn_areas%22%3A%5B%7B%22x%22%3A4%2C%22y%22%3A5%2C%22w%22%3A847%2C%22h%22%3A845%2C%22no_balls%22%3A400%2C%22min_radius%22%3A4%2C%22max_radius%22%3A4%2C%22min_vel%22%3A0%2C%22max_vel%22%3A0%2C%22vel_angle%22%3A-1%7D%2C%7B%22x%22%3A393%2C%22y%22%3A399%2C%22w%22%3A11%2C%22h%22%3A12%2C%22no_balls%22%3A1%2C%22min_radius%22%3A4%2C%22max_radius%22%3A4%2C%22min_vel%22%3A2000%2C%22max_vel%22%3A2000%2C%22vel_angle%22%3A-1%7D%5D%2C%22tracing%22%3Afalse%2C%22collisions%22%3Atrue%2C%22gravity%22%3A0%2C%22cor%22%3A1%2C%22size%22%3A856%7D'>entropy</a> simulation; or create <a href='https:/joeiddon.github.io/balls/builder'>create your own</a>.</h2>


<p>
The amount of physical phenomenon that can be visualised through mere "bouncing balls" is staggering.
</p>

<p>
Once quantum computers are able to maintain numerous qubits with high stability, we will be able to simulate atomic and molecular behaviour in great depth. This should lead to advancements in areas such as drug research and material science.
</p>

<p>
Whilst we're waiting, I thought I'd go about trying to simulate particle collision behaviour on a classical computer.
</p>

<p>
This was achieved in an HTML Canvas Element which I interfaced with directly through the JavaScript language.
</p>

<p>
The remainder of this post will discuss the implementation of this simuation. There are links at the top to a couple of pre-constructed simulations alongside a link to build your own.
</p>

<hr>

<p>
The code for this project is <a href='https://github.com/joeiddon/balls'>here on GitHub</a>.
</p>

<p>
In terms of data structures, each ball is stored with basic properties: a position vector, a velocity vector and a radius. Since all balls have identical artificial density, the mass of each ball is proportional to its radius so would be reduntant to store.
</p>

<p>
The verticies of the rectangular obstacles (hereafter referred to as "bollards") are represented through position vectors.
</p>

<p>
These data structures are randomly populated at run time based on data that is encoded in the URI of the webpage. [To run the simulation, a link which includes the correct encoded data must be generated by the world builder page, <code>builder.html</code>, that is linked at the top of this post.]
</p>

<p>
After initialisations, the main event loop is entered with <a href='https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame'><code>window.requestAnimationFrame</code></a>.
</p>

<p>
At the end of the event loop function, the function recursively requests itself for the next animation frame too. This gives the browser time to process user events, but avoids any explicit delays in the code to ensure the smoothest rendering. We are also passed a timestamp which allows us to compute a time delta from the previous frame. This is then encorporated into our equations of motion.
</p>

<p>
We can now concern ourselves with the core of the code. Which is coordinated from this main loop.
</p>

<p>
We consider the following tasks,
</p>

<ol>
<li>applying the acceleration due to gravity to each ball;
<li>processing any ball~wall collisoins;
<li>processing any ball~ball collisions;
<li>processing any ball~bollard collisions;
<li>incrementing the ball position vectors by their velocity vectors;
<li>re-drawing the canvas.
</ol>

<p>
Having broken down the code, the main event loop, seen below, is quite readable.
</p>

<pre>
/******************
      MAIN LOOP
*******************/

function update(time_ms){
    time_delta_s = last_time_ms ? (time_ms - last_time_ms) / 1000 : 0;
    last_time_ms = time_ms;

    apply_gravity();

    wall_collisions();
    ball_collisions();
    bollard_collisions();

    update_ball_positions();

    clear_screen();
    draw_screen();

    requestAnimationFrame(update);
}
</pre>

<p>
I do not wish to step through the remainer of the code line-by-line. Instead, I will cast a more asbstract overview of the implementation.
</p>

<p>
Firstly, applying gravity is simple. Acceleration is the rate of change of velocity, <code>dv/dt = a</code>. Integrating this, we have <code>v = at + c</code>. Letting <code>v = u</code> at <code>t = 0</code> we derive one of the five equations of motion: <code>v = u + at</code>. So we simply need to increment the y-component of each ball's velocity by gravity scaled by the time delta.
</p>

<p>
As for collisions, wall collision is simple, but ball and bollard collision handling is considereably more challenging.
<p>

<p>
In general, collision processing can be broken down into two (or three if your include assigning velocities) stages:
</p>

<ol>
<li>detecting a collision;
<li>calculating velocities.
</ol>

<p>
We now see how the case of the wall is simple: if the orthogonal distance from the ball's centre to a wall is less than its radius, we invert the respective velocity component by multiplying it by <code>-1</code>.
</p>

<p>
Progressing to the easier of the two remaining cases, the ball~bollard collision, we see the computation becomes more difficult.
</p>

<p>
In this case, detection is carried out by considering the perpendicular (shortest) distance between the ball and the side of the rectangle that is currently being evaluated - if it is less than the ball's radius, then we <em>may</em> have a collision. We must additionally check that the ball is within the two other parrallel sides of the rectangle. This is computed by checking whether the sign of the distance between the ball and each of these two sides match (this works since the verticies of the rectange are cyclically numbered).</p>

<p>
How is this point-line distance calculated though? Well on reflection, I looked up the <a href='https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line'>proper way</a> to do so on Wikipedia, but that was after I had discovered my own long-winded method. I used a matrix to rotate all three points so that the two points on the line lied horizontally. This meant that the distance could then be read off directly as the difference between the y-coordinates of the transformed point and one of the transformed line points. These calculations are seen belwo.
</p>

<p>
Now we must consider step (2). In order to calculate the resulting velocity vector, we must resolve the ball's current velocity vector into components that are tangent and normal to the line of least distance between the ball and the line. We can then simply invert the normal component and then combine the two vectors back together.
</p>

<p>
And how do we resolve the velocity vector? I found that you can use plain geometry or, again, a little linear algebra. These calculations, along with my way of calculating point-line distance, are seen below.
</p>

<img src='/images/balls/calculations.jpg'></img>

<p>
And that completes ball~bollard collisions.
</p>

<p>
In the case of ball~ball collisions, detection is done by seeing if the magnitude of the centre-centre distance, calculated by pythagoras, is less than the sum of the radii.
</p>

<p>
We then follow a similar thought process to that of the ball~bollard collisions resolving the two ball velocities into normal and tangent components. However we now use ideas of energy and momentum to calculate the final normal component before combining the vectors back together again.
</p>

<p>
To resolve the velocities, the calculations are much the same as before, so I will not post those.
</p>

<p>
The important step here is how we calculate the final normal velocities of the two balls given their initial velocities and their masses. Lacking much knowledge further than momentum is mass times velocity (<code>p = mv</code>) and that "momentum is conserved" (i.e. <code>m1u1 + m2u2 = m1v1 + m2v2</code>), I needed some assistance working out the final normal velocities in an elastic (a special type of collision in which kinetic energy is conserved) collision. I came across <a href='http://farside.ph.utexas.edu/teaching/301/lectures/node76.html'>this resource</a> that derived the 1d equation I desired. And in essence, that completes ball~ball collisions; we just combine the modified normal and unchagned tangent vectors and assign them back to their respective balls.
</p>

<p>
That's pretty much all. As previously stated, the world builder page allows for the design of a simulation which is encoded in a URI query parameter in the form of a link - allowing you to make your own simulations. On the other hand, just take a look at the few I made myself which are linked at the top of the post.
</p>
